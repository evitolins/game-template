#!/usr/bin/env bash

# 
# bash_utils
# 
# Summary:
# 
#     Generic constants and utilities to be sourced by other scripts 
#
#
# Pre-Hook Checklist:
# 
#     0. Check if Bash version is supported
#     1. Check if Git version is supported
#     2. Check if LFS version is supported
#        - 2a. Collect LFS Tracking Extensions
#        - 2b. Check if LFS hooks are properly installed
#     3. Block files larger than X from being committed without using LFS
#     4. Check if .gitattributes has been edited
#         - 4a. Require the .gitattributes changes be staged for commit
#         - 4b. Check repo history for previously committed/untracked files of
#               the newly tracked extensions
#           - Warn user that these changes probably require a REPO rebuild to
#             avoid future errors
#     5. Check if files contain an uppercase extension
#         - 5a. if so, stop the commit and suggest renaming the files before
#               committing
#
#
# Helpful snippets:
#    git status --porcelain
#    git lfs status --porcelain
#
#
# Reference:
#    http://stackoverflow.com/questions/3878624/how-do-i-programmatically-determine-if-there-are-uncommited-changes
#

# Success/Failure functions
commit_failure ()
{
    echo ""
    echo -e "${R}Your commit has failed. ${BLD}Please review the messages above for suggestions to fix the issues.${N}"
    echo ""
    exit 1
}

commit_success ()
{
    echo ""
    echo -e "${icon_mugs} ${G}Your commit was successful! ${BLD}Carry on my wayward son...${N}"
    echo ""
}



# Import Dependencies
#   - paths must be relative to the git repo's root path
DIR=$(git rev-parse --show-toplevel)
if [[ ! -d "$DIR" ]]
then
    echo "Error: Git repo was not found."
    commit_failure
else
    source "$DIR/utils/bash_utils"
fi


# File Size Limits
hard_limit=$(($MB*2))
soft_limit=$(($MB*1))
hard_limit_human=$(echo $hard_limit| awk '{ foo = $1 / 1024 / 1024 ; print foo "MB" }')
soft_limit_human=$(echo $soft_limit| awk '{ foo = $1 / 1024 / 1024 ; print foo "MB" }')





# Gather Needed Data
required_git_version="2.10.2"
required_lfs_version="1.5.5"

user_git_version=$(git version | awk '{print $3}')
user_lfs_version=$(git lfs version | awk '{print $1}' | awk -F '/' '{print $2}')
lfsTrackedExts=""

compare_git_version=$(vercomp $user_git_version $required_git_version)
compare_lfs_version=$(vercomp $user_lfs_version $required_lfs_version)

state_git_version_ok=$( [ ! "$compare_git_version" -lt 2 ]; echo $? )
state_lfs_version_ok=$( [ ! "$compare_lfs_version" -lt 2 ]; echo $? )
state_lfs_is_required=false
state_lfs_hooks_are_installed=false
state_lfs_gitattributes_edited=false
state_lfs_uppercase_fileexts_detected=false
state_errors=0







echo -e "${BLD}------------------------------------------------------${N}"
echo -e "${BLD}              Hack and Paint [pre-commit]${N}"
echo -e "${BLD}------------------------------------------------------${N}"

# Check if this is the initial commit
if git rev-parse --verify HEAD >/dev/null 2>&1
then
    # echo -e " About to create a new commit..."
    against=HEAD
else
    # echo -e " Hack and Paint [pre-commit]: About to create the first commit..."
    against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
fi



#######################################
# 1) Check if Git version is supported
echo -e "${BLD}1. Verify Git${N}"
git_compare_string="$user_git_version $(vercomp_char $compare_git_version) $required_git_version"
if [ "$state_git_version_ok" == 1 ] ;
then
    echo -e "   $icon_positive GIT is valid: $git_compare_string"
else
    echo -e "   $icon_negative GIT is not valid: $git_compare_string"
    commit_failure
fi



#######################################
# 2) Check if LFS is being used and version is supported
# If .gitattributes exists, collect all tracked extensions
# TODO: Switch logic to use `git lfs track`
echo -e "${BLD}2. Verify Git-LFS${N}"
if [ -r ./.gitattributes ]
then
    lfs_compare_string="$user_lfs_version $(vercomp_char $compare_lfs_version) $required_lfs_version"
    if [ "$state_lfs_version_ok" == 1 ] ;
    then
        echo -e "   $icon_positive LFS is valid: $lfs_compare_string" 
    else
        echo -e "   $icon_negative LFS is not valid: $lfs_compare_string"
        commit_failure
    fi

    #######################################
    # 2a) Collect LFS Tracking Extensions
    #  NOTICE: This will probably break, if we start tracking directories, etc
    #  NOTICE: This also assumes there is only a .gitattributes in the root directory
    echo -e "${BLD}2a. Collect LFS Tracking Extensions${N}"
    state_repo_uses_LFS=true
    lfsTrackedExtsCount=$(grep "filter=lfs diff=lfs merge=lfs -text" .gitattributes |sed 's/\|/ /'| awk '{print $1}'| cut -d'.' -f 2 | wc -l| awk '{print $1}')
    lfsTrackedExtsArr=$(grep "filter=lfs diff=lfs merge=lfs -text" .gitattributes |sed 's/\|/ /'| awk '{print $1}'| cut -d'.' -f 2 | sort)
    lfsTrackedExts=$(grep "filter=lfs diff=lfs merge=lfs -text" .gitattributes |sed 's/\|/ /'| awk '{print $1}'| cut -d'.' -f 2 | sort | paste -sd "," -)
    echo -e "   $icon_positive .gitattributes found"
    echo -e "      $icon_info $lfsTrackedExtsCount tracked extensions found"
    # # Echo each extension
    # for i in $lfsTrackedExtsArr
    # do
    #    echo "      - $i"
    # done

    #######################################
    # 2b) Check if LFS hooks are properly installed
    git lfs install
else
    echo -e "   $icon_warning .gitattributes missing" 
    state_repo_uses_LFS=false
    lfsTrackedExts=""
fi



#######################################
# 3) Block files larger than X from being committed without using LFS
# 
#    Because the LFS-tracked file size returned is actually the size of the
#    pointer file instead.  You can assume any file size listed over ~130b is
#    not being tracked.
#    
echo -e "${BLD}3. Block files larger than ${hard_limit_human} from being committed without using LFS${N}"
list_new_or_modified_files | check_file_size
files_too_large=$?

if [ $files_too_large -gt 0 ]; then
    commit_failure
fi



#######################################
# 4) Check if .gitattributes has been edited.
#     - 4a. Require the .gitattributes changes be staged for commit
#     - 4b. Check history for repo, and see if the extension has been
#           previously committed, untracked sure the newly tracked files/exts
#           had never been commmitted before
#     - 4c. warn user that these changes probably require a REPO rebuild to
#           avoid future errors
#     
# We must check .gitattributes, even if it's not staged, as LFS will use
# .gitattributes as it exists in the working directory.
#    
# If new extentions are tracked with LFS, we need to verify that the repository
# does not have previous commits with files matching that extention (not
# tracked in LFS).  This will require extra attention, as the repo will
# continue to display errors, unless it's history is repared (ie. BFG, etc.)
# 

echo -e "${BLD}4. Check if .gitattributes has been edited${N}"
while read status_feed
do
    f=$(echo $status_feed | awk '{print $2}')
    filename=$(basename "$f")
    path_no_extension="${f%.*}"
    if [[ $filename = ".gitattributes" ]] ;
    then
        echo -e "   $icon_warning $f has been edited"
        echo -e "      $icon_info $f this file must be staged."
    fi
done < <(git status --porcelain)

# 4a. Require the .gitattributes changes be staged for commit
echo -e "${BLD}4a. Require the .gitattributes changes be staged for commit${N}"
# SADNESS: I CAN NOT GET `git ls-files --modified` to return any data, yet `git ls-files` will.
# while read unstaged_files
# do
#     f=$unstaged_files
#     filename=$(basename "$f")
#     echo -e "$unstaged_files"
# done < <(git ls-files --modified)


echo -e "${BLD}4b. Check repo history for previously committed/untracked files of the newly tracked extensions${N}"
echo -e "   ${icon_warning} This feature is currently disabled.${N}"



#######################################
# 5) Check if files contain an uppercase extension
#     - 5a. if so, stop the commit and suggest renaming the files before committing
echo -e "${BLD}5. Check if files contain an uppercase extension${N}"
while read status_feed
do
    f=$(echo $status_feed | awk '{print $2}')
    filename=$(basename "$f")
    ext="${filename##*.}"
    filename="${filename%.*}"
    path_no_extension="${f%.*}"
    ext_lowercase=$(echo "$ext" | awk '{print tolower($0)}')
    if [[ $ext =~ [A-Z] ]] ;
    then
        echo -e "   $icon_negative $f can not have an uppercase file extension." 
        echo -e "      $icon_info please rename using ${CODE} git mv $f ${path_no_extension}.${ext_lowercase} ${N}" 
        commit_failure
    fi
done < <(git lfs status --porcelain)



#######################################
# SUCCESS
commit_success





# BLOCK COMMIT SUCCESS FOR TESTING
echo -e "p.s. - Just kidding, commit success is disabled for testing.\n"; exit 1;
